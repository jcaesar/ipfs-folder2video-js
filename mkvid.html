<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Make videos from ipfs file lists</title>
		<style type="text/css">
			* { /* border: 1px dotted red; */ margin: 0px; }
			body { padding: 2ex; }
		</style>
		<script src="js/jquery.min.js"></script>
		<script src="js/whammy.js"></script>
		<script src="js/natsort.min.js"></script> <!-- natsort 1.6 -->
		<script src="js/somefuncs.js"></script>
		<script type="text/javascript">
			// Note that this entire idea violates "Bring your application to your data, not the other way around". ¯\_(ツ)_/¯

			var gw = autogw();
			var scale = 1000;
			var parallelload = 6;
			var mode = "webm";
			
			var strings = {
				WebPWarning: { 
					en: "WARNING: Your browser lacks native WebP support. At the time of this writing, Chrome was tested and worked. This is likely going to be slow.",
					de: "WARNING: Ihr browser unterstützt das WebP-Format nicht vollständig. Die Erstellung des Videos könnte beträchtliche Zeit in anspruch nehmen."
				},
				Search: {
					en: "Searching for files (IPFS-Gateway: ",
					de: "Suche nach Dateien (IPFS-Zugang: "
				},
				Found: {
					en: ["Found ", " images (", ")."],
					de: ["", " Bilder (", ") gefunden."]
				},
				Exit: {
					en: "Exiting Programme.",
					de: "Programm Beendet."
				},
				DownloadFail: {
					en: "Failed to get file list: ",
					de: "Fehler beim Auflisten der Dateien: "
				},
				Downloading: {
					en: "Downloading",
					de: "Herunterladen"
				},
				Enqueuing: {
					// Well, not actually necessarily done in this step. But oh well…
					en: "Image Encoding",
					de: "Bildcodierung"
				},
				Encoding: {
					en: "Video Encoding",
					de: "Videocodierung"
				},
				DoneS: {
					en: "Done. Size: ",
					de: "Fertig. Größe: "
				},
				Dur: {
					en: " Duration: ",
					de: " Länge: "
				},
				Dim: {
					en: " Dimensions: ",
					de: " Auflösung: "
				},
				Save: {
					en: "Save",
					de: "Speichern"
				}
			}
			var lst = localize(strings);

			function usage() {
				var showgw = autogw();
				log("Script for converting a series of images in an IPFS directory to a WebM directly in browser.")
				log("");
				log("Script requires arguments in the search string (i.e. mkvid.html?arg=value&…):");
				log("    Required: h - ipfs-hash resolving to folder of images.");
				log("    Required: f - RegExp to filter files in folder and extract a numbering for the images.");
				log("    Optional: s - Scale factor for time codes extracted from image numbering. Default: " + scale + " ms");
				log("    Optional: m - Mode. Default: " + mode + " Available: webm,");
				log("    Optional: gw - IPFS gateway. Default: current gateway, if available (e.g.: " + uniq([gw, showgw, "https://ipfs.io"]).join(", ") + ")");
				log("    Optional: j - Maximum number of images requested in parallel. Default: " + parallelload + " ms");
				log("");
				var m = new URL(document.location);
				m.search = "h=QmRqjxJj1AP2WTNJfKoWuJKKYCDNdYDWjzSGuTRW4XAadi&f=c-([0-9]*).jpeg&s=0.2&gw=" + showgw + "&j=12";
				var e = document.createElement('span');
				e.appendChild(document.createTextNode("Example: "));
				var a = document.createElement('a');
				a.href = m.href;
				a.appendChild(document.createTextNode(m.href));
				e.appendChild(a);
				append_log(e);
			}
			
			function main() {
				var query = getQueryParams(document.location.search);
				if (query.gw)
					gw = query.gw;
				var re;
				try {
					re = new RegExp(query.f);
					scale = parseFloat(query.s) || scale;
					parallelload = Math.max(1, parseInt(query.j) || parallelload);
				} catch(e) {}
				if (!re || !query.f || !query.h)
					return usage();
				if(!(/^data:image\/webp;base64,/ig).test(document.createElement('canvas').toDataURL('image/webp')))
					log(lst.WebPWarning);
				log(lst.Search + gw + ")…");
				$.getJSON(gw + "/api/v0/ls/" + query.h, function(fd) {
					var links = fd.Objects[0].Links;
					var objs = [];
					var size = 0;
					for(var i = 0; i < links.length; i++) {
						var l = links[i];
						var m = re.exec(l.Name);
						if(m) {
							objs.push(l);
							size += l.Size;
							l.Match = m;
							l.T = parseFloat(m[m.length - 1]);
						}
					}
					log(lst.Found[0] + objs.length + lst.Found[1] + formatSizeUnits(size) + lst.Found[2]);
					if (!(objs.length >= 1)) {
						log(lst.Exit);
						return;
					}
					getVid(objs);
				})
				.fail(function(jqxhr, textStatus, error) {
					var err = textStatus + ", " + error;
					log(lst.DownloadFail + err);
				});
			}

			function getVid(objs) {
				var sline = log();
				var total = objs.length;
				var loaded = [];
				var stus = function() { sline.textContent = lst.Downloading + ": " + loaded.length + "/" + total; };
				var loading = 0;
				var nextImg = function() {
					stus();
					var obj = objs.pop();
					if (!obj) {
						if (loading == 0)
							enqueueVid(loaded);
						return;
					}
					loading++;
					var img = obj.Img = new Image();
					img.crossOrigin = "Anonymous";
					loadfinished = function(rem) {
						if (rem.parentNode)
							rem.parentNode.removeChild(rem);
						loading--;
						nextImg();
					};
					img.onload = function() {
						window.setTimeout(function() {
							loaded.push(obj);
							loadfinished(obj.Img);
						}, 100);
					};
					img.onerror = function() { 
						total--;
						loadfinished(obj.Img);
					};
					img.src = gw + "/ipfs/" + obj.Hash;
					img.style = 'width: 60px; height: 60px; margin: 5px;';
					sline.parentNode.appendChild(img);
				};
				for (var i = 0; i < parallelload; i++)
					nextImg();
			}

			function enqueueVid(objs) {
				var vid = new Whammy.Video(/*undefined, 1*/);
				var ns = natsort({ insensitive: true });
				objs.sort(function(a,b) { return ns(a.Name, b.Name); });
				var sline = log();
				var i = 0;
				var stus = function() { sline.textContent = lst.Enqueuing + ": " + i + "/" + objs.length; };
				stus();
				var nextImg = function() {
					stus();
					if (i < objs.length)
						setTimeout(nextImg, 0);
					else
						return makeVid(vid);
					if (i + 1 < objs.length)
						objs[i].Dur = objs[i + 1].Dur = (objs[i + 1].T - objs[i].T) * scale;
					var obj = objs[i];
					i++;
					var img = obj.Img;
					var cvs = document.createElement("canvas");
					img.style = '';
					cvs.height = img.height; // TODO: Make sure that's the same the entire video
					cvs.width = img.width;
					var ctx = cvs.getContext("2d");
					ctx.drawImage(img, 0, 0);
					vid.add(cvs, Math.max(Math.min(obj.Dur, 32766), 1));
				}
				setTimeout(nextImg, 0);
			}

			function makeVid(vid) {
				var sline = log();
				var stus = function(i, total) { sline.textContent = lst.Encoding + ": " + (i + 1) + "/" + total; };
				stus(-1, "?");
				  setTimeout(function() {vid.compile(false, useVid, stus);}, 0);
			}
			
	  		function handleBlob(vid_blob) {
				var vid_url = (window.URL || window.webkitURL).createObjectURL(vid_blob);
				var vid_e = document.createElement('video');
				if (vid_e.canPlayType(vid_blob.type).length > 0) {
					vid_e.url = vid_url;
					vid_e.setAttribute('autoplay', '');
					vid_e.setAttribute('controls', '');
					append_log(vid_e);
					vid_e.addEventListener('loadedmetadata', function() {
						var w = 640, h = 480;
						if(vid_e.videoWidth > 0 && vid_e.videoHeight > 0) {
							w = vid_e.videoWidth; h = vid_e.videoHeight;
							donel.textContent += lst.Dim + w + "×" + h;
						}
						if (vid_e.duration)
							donel.textContent += lst.Dur + vid_e.duration + " s";
						vid_e.width = w; vid_e.height = h;
					});
				}
				var dl = document.createElement('a');
				dl.download = 'lapse.' + vid_blob.type.replace(/^.*\//,'');
				dl.href = vid_url;
				dl.appendChild(document.createTextNode(lst.Save));
				return dl;
			}

			function useVid(vid_blob) {
				var donel = log(lst.DoneS + formatSizeUnits(vid_blob.size));
				append_log(handleBlob(vid_blob));
				mp4Vid(vid_blob);
			}

			function mp4Vid(vid) {
				var worker = new Worker("js/ffmpeg-worker-mp4.js");
				worker.onmessage = function(e) {
					var msg = e.data;
					switch (msg.type) {
						case "ready":
							var fileReader = new FileReader();
							fileReader.onload = function() {
								worker.postMessage({
									type: "run", 
									arguments: ["-hide_banner",
										"-i", "/data/lapse.webm",
										"-vsync", "2",
										"-movflags", "faststart",
										"-pix_fmt", "yuv420p",
										//"-vf", "\"scale=trunc(iw/2)*2:trunc(ih/2)*2\"", // Let's just hope it's divisible by 2
										"lapse.mp4"
									],
									TOTAL_MEMORY: vid.size * 4,
									WORKERFS: { blobs: [{name: "lapse.webm", data: vid}], mountpoint: "/data" },
									//MEMFS: [{ name: "lapse.webm", data: this.result }],
								});
							};
							fileReader.readAsArrayBuffer(vid);
							break;
						case "stdout":
							console.log(">> " + msg.data);
							break;
						case "stderr":
							console.log("!! " + msg.data);
							break;
						case "done":
							log("Done");
							var m0 = msg.data.MEMFS[0];
							var blb = new Blob(m0.data, { type: "video/" + m0.name.replace(/^.*\./, '') });
							append_log(handleBlob(blb));
							break;
						case "exit":
							console.log("Process exited with code " + msg.data);
							worker.terminate();
							break;
					}
				};
				worker.onerror = function(e) {
					log("Error from worker: " + JSON.stringify(e));
				};
				worker.onmessageerror = function(e,a,b) {
					log("Error message worker: " + JSON.stringify(e) + JSON.stringify(a) + JSON.stringify(b));
				};
			}

			$(document).ready(main);
		</script>
	</head>
	<body>
	</body>
</html>
