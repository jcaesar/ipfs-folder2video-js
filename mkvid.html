<!DOCTYPE html>
<html>
	<head>
		<meta charset="UTF-8">
		<title>Make videos from ipfs file lists</title>
		<script src="jquery.min.js"></script>
		<script src="whammy.js"></script>
		<script src="natsort.min.js"></script> <!-- natsort 1.6 -->
		<script src="somefuncs.js"></script>
		<script type="text/javascript">
			// Note that this entire idea violates "Bring your application to your data, not the other way around". ¯\_(ツ)_/¯

			
			function log(str) {
				var t = document.createTextNode(str);
				append_log(t);
				return t;
			}

			function append_log(obj) {
				document.body.appendChild(obj);
				document.body.appendChild(document.createElement('br'));
			}
			
			var gw = autogw();
			var scale = 1000;

			function usage() {
				var showgw = autogw();
				log("Script for converting a series of images in an IPFS directory to a WebM directly in browser.")
				log("");
				log("Script requires arguments in the search string (i.e. mkvid.html?arg=value&…):");
				log("    Required: h - ipfs-hash resolving to folder of images.");
				log("    Required: f - RegExp to filter files in folder and extract a numbering for the images.");
				log("    Optional: s - Scale factor for time codes extracted from image numbering. Default: " + scale + " ms");
				log("    Optional: gw - IPFS gateway. Default: current gateway, if available (e.g.: " + uniq([gw, showgw, "https://ipfs.io"]).join(", ") + ")");
				log("");
				var m = new URL(document.location);
				m.search = "h=QmRqjxJj1AP2WTNJfKoWuJKKYCDNdYDWjzSGuTRW4XAadi&f=c-([0-9]*).jpeg&s=0.2&gw=" + showgw;
				var e = document.createElement('span');
				e.appendChild(document.createTextNode("Example: "));
				var a = document.createElement('a');
				a.href = m.href;
				a.appendChild(document.createTextNode(m.href));
				e.appendChild(a);
				append_log(e);
			}
			
			function main() {
				var query = getQueryParams(document.location.search);
				if (query.gw)
					gw = query.gw;
				var re;
				try {
					re = new RegExp(query.f);
					scale = parseFloat(query.s) || scale;
				} catch(e) {}
				if (!re || !query.f || !query.h)
					return usage();
				if(!(/^data:image\/webp;base64,/ig).test(document.createElement('canvas').toDataURL('image/webp')))
					log("WARNING: Your browser lacks native WebP support. At the time of this writing, Chrome and Safari were tested and worked. This is likely going to be slow and produce garbage output.");
				log("Searching (Gateway: " + gw + ")…");
				$.getJSON(gw + "/api/v0/ls/" + query.h, function(fd) {
					var links = fd.Objects[0].Links;
					var objs = [];
					var size = 0;
					for(var i = 0; i < links.length; i++) {
						var l = links[i];
						var m = re.exec(l.Name);
						if(m) {
							objs.push(l);
							size += l.Size;
							l.Match = m;
							l.T = parseFloat(m[m]);
						}
					}
					log("Found " + objs.length + " images (" + formatSizeUnits(size) + ")");
					if (!(objs.length >= 1)) {
						log("Exiting.");
						return;
					}
					ns = natsort({ insensitive: true, desc: true })
					objs.sort(function(a,b) { return ns(a.Name, b.Name); });
					getVid(objs);
				})
				.fail(function(jqxhr, textStatus, error) {
					var err = textStatus + ", " + error;
					log("Failed to get file list: " + err);
				});
			}

			function getVid(objs) {
				var Tmin = objs[objs.length - 1].T;
				var sline = log();
				var total = objs.length;
				var stus = function() { sline.textContent = "Download: " + (total - objs.length) + "/" + total; };
				stus(0);
				var vid = new Whammy.Video();
				var nextImg = function() {
					stus();
					var obj = objs.pop();
					if (!obj) {
						stus();
						makeVid(vid);
						return;
					}
					var img = new Image();
					img.crossOrigin = "Anonymous";
					img.onload = function() {
						var cvs = document.createElement("canvas");
						cvs.height = img.height;
						cvs.width = img.width;
						var ctx = cvs.getContext("2d");
						ctx.drawImage(img, 0, 0);
						var dur = 1000;
						if (objs.length > 0) {
							dur = (objs[objs.length - 1].T - obj.T) * scale;
							objs[objs.length - 1].Dlast = dur;
						} else if(obj.Dlast) {
							dur = obj.Dlast;
						}
						//log("N: " + obj.Name + " T: " + obj.T + " Tmin: " + Tmin + " s: " + scale + " dur: " + dur);
						vid.add(cvs, Math.max(Math.min(dur, 32766), 1));
						nextImg();
					};
					img.src = gw + "/ipfs/" + obj.Hash;
				};
				nextImg();
			}

			function makeVid(vid) {
				var sline = log();
				var stus = function(i, total) { sline.textContent = "Encoding: " + (i + 1) + "/" + total; };
				stus(-1, "?");
				vid.compile(false, useVid, stus);
			}

			function useVid(vid_blob) {
				var donel = log("Done. Size: " + formatSizeUnits(vid_blob.size));
				var vid_url = (window.URL || window.webkitURL).createObjectURL(vid_blob);
				var vid_e = document.createElement('video');
				if (vid_e.canPlayType(vid_blob.type).length > 0) {
					vid_e.url = vid_url;
					vid_e.setAttribute('autoplay', '');
					vid_e.setAttribute('controls', '');
					append_log(vid_e);
					vid_e.addEventListener('loadedmetadata', function() {
						var w = 640, h = 480;
						if(vid_e.videoWidth > 0 && vid_e.videoHeight > 0) {
							w = vid_e.videoWidth; h = vid_e.videoHeight;
							donel.textContent += " Dimensions: " + w + "×" + h;
						}
						if (vid_e.duration)
							donel.textContent += " Duration: " + vid_e.duration + " s";
						vid_e.width = w; vid_e.height = h;
					});
				}
				var dl = document.createElement('a');
				dl.download = 'lapse.webm';
				dl.href = vid_url;
				dl.appendChild(document.createTextNode("Save"));
				append_log(dl);
			}

			$(document).ready(main);
		</script>
	</head>
	<body>
	</body>
</html>
